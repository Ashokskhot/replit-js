Brute Force: Simple and exhaustive technique that evaluates every possible outcome to find the best solution. Ex: Linear search
Greedy: Choose the best time at the current time, without any consideration of the future. Ex: Dijkstra's Algorithm, Prim's Algorithm and Kruskal's algorithm
Divide and conquer: Divide the problem into smaller sub-problems. Each sub-problem then solved and the partial solutions are recombined to determine the overall solution. Ex: Binary search, quick sort, merge sort and tower of hanoi
Dynamic programming: Divide the problem into smaller sub-problems. Break it down into smaller but overlapping sub-problems. Store the result and reuse it for the same sub-problems. This is called memoization and is a optimization technique that improves the time complexity of your algorithm. Ex: Fibonacci numbers and climbing staircase
Backtracking: Generate all possible solutions. Check if the solution satisfies all the given constraints and only then you procees with generating subsequent solutions. If the constraints are not satisfied, backtrack and go back on a different path to find the solution. Ex: N-Queens problem